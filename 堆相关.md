## Heap

### Category

https://github.com/ray-cp/pwn_category#io_file







### 变化

libc2.29 之后加入了 pre_size 和 size的校验，加大了先前简单的off-by-one构造overlapping 利用条件和难度

```c
+0x00 [       top        |  last_remainder   ]
+0x10 [ unsorted bin fd  |  unsorted bin bk  ]
+0x20 [ smallbin 0x20 fd | smallbin 0x20 bk  ]
+0x30 [ smallbin 0x30 fd | smallbin 0x30 bk  ]
+0x40 [ smallbin 0x40 fd | smallbin 0x40 bk  ]
+0x50 [ smallbin 0x50 fd | smallbin 0x50 bk  ]
+0x60 [ smallbin 0x60 fd | smallbin 0x60 bk  ] /* 0x68 */
```



##### https://bbs.pediy.com/thread-249713.htm#msg_header_h2_2

### Tcache与off-by-NUll

https://n132.github.io/2019/06/11/2019-06-11-OFF-BY-ONE-2-2n/#2-29

#### Tag：

- 基本上就是A-B-C
- shrink B （首先得得到>0x100的chunkB，这就是个考点，可以是malloc_consolidate）
- 得到B这个得是**unsortedbin**，**这样过unlink的check**。还得size够大，0x100之类的

#### glibc-2.27 

 **检查 要脱链的chunk的size是否和下一个chunk的pre_size相同**

-  法一：

```python
1. malloc A-B-C
2. free(A) # 进unsorted bin，为了在fd和bk布置相关数据
   free(B) # 进tcache，在B中伪造出A的pre_size，其实就是提前把目标想要合并的chunk之后的chunk释放就行
           # 
3. B伪造C的pre-size，并n-b-o
4. free(C), overlapping B
5. 再取出B
```

- 法二：

![image-20201014094711142](C:\Users\l00574113\AppData\Roaming\Typora\typora-user-images\image-20201014094711142.png)

```python
# 即shrink了chunk，之所以是shrink就是A-B-C,shrink了B之后，再申请的时候不会改变C中保存的B的pre_size（也就能overlapping的unlink）
# 同样申请出p2也得free，以保证有p1的pre-size，过check
# 且P1中的fd和bk也保证了 unlink的正确性
```





##### Ex： 2018 LCTF easy-heap

- **Tag：**交错free，构造unlink，overlapping

- 交错delete  1-3 、 5-9、 0-4
- 填满Tcache，进unsorted bin
- 利用两个紧邻的chunk，前一个是used。后一个被null by one 然后前向合并

##### Ex：2018 Hitcon children_tcache

- **Tag**： 法一利用

- https://bbs.pediy.com/thread-249713.htm#msg_header_h3_1
- https://aidaip.github.io/binary/2020/02/19/glibc2.29-off-by-one.html
  - A-B-C
  - 通过B伪造C的pre-size并Null-By-One
  - 由于B的确有A的pre_size,所以可以过2.27的check
  - 释放C，ABC合并，overlap了ChunkB
  - **再申请切割unsortedbin，B的位置会进入unsortedbin，有libc-addr，再申请B，即可dup B**

##### Ex：2018 Hitcon Baby_tcache

- **Tag**：IO_File任意read
- 结合了IO_file ,这里构造的是_IO_write_base，并且改的是flag 为0xfbad1800  （**两种绕过打印方式之一**）



##### Ex： 0CTF2019  babyheap2.28

- **Tag：**  malloc_consolidate-by topchunk ， **calloc不会申请tcache的chunk！！**
-  **calloc初始化堆内容，所以这里泄露libc是根据切割overlapping的chunk，使得used的chunk被链入unsortedbin**

http://matshao.com/2019/03/28/Babayheap-2019/

http://blog.eonew.cn/archives/1035#i-7

https://www.anquanke.com/post/id/176139#h2-7

https://www.anquanke.com/post/id/176139#h3-9

- **Key**
  - 压缩top chunk，使其减少
  - malloc触发 malloc_consolidate，会将fastbin都合并，放入unsortedbin。
  - **由于是calloc，不会从tcache申请**，从而可以直接溢出这次malloc的chunk到unsortedbin的pre_inuse
  - chunk overlaping
  - 泄露地址
  - **劫持top chunk**
    - 先将top_chunk申请出来，以改变top_chunk
    - 接着修改top_chunk的内容
  - 劫持__realloc_hook and __malloc_hook
  - onegadget拿shell

![image-20201015152459483](C:\Users\l00574113\AppData\Roaming\Typora\typora-user-images\image-20201015152459483.png)



#### glibc-2.29

##### 新check

  会根据当前要free的pre_size 找到上一个chunk，校验 size 和 presize

##### off-by-one（通过A前面的chunk改A的size）

- X-A-B-C 四个chunk，通过C构造A的size，即可过  C_pre_size  == A_size

- A-B-C，三个chunk，extend改B的size包含C，free(B), 得到两个B

##### off-by-null













###### Ex：Balsn CTF 2019 PlainText

http://blog.eonew.cn/archives/1233













### largebin attack

#### glibc-2.23

https://veritas501.space/2018/04/11/Largebin%20%E5%AD%A6%E4%B9%A0/

###### Ex：rctf2019-babyheap

###### Ex：0ctf2018-heapstorm2

#### glibc-2.29  

http://blog.eonew.cn/archives/1248

##### Ex：Hitcon-Ctf-2019  one punch man

### 



### malloc_consolidate

https://b0ldfrev.gitbook.io/note/miscellaneous/ctf-bi-ji#mallocconsolidate-bi-ji

#### 几种情况产生consolidae

- 分配smallbin，如果smallbin还为初始化双向循环链表，则将fastbin中的chunk合并
- 分配largebin，如果有fastbin，则合并fastbin中的chunk
  - house-of-orange用到这个方法产生smallbin，见《some-heap-tips》
- top_chunk大小不够时，会查看fastbin，若有，则consolidate
  - 见0ctf2019-babyheap2.29
- 在释放chunk时，遇到相邻空闲chunk合并或者与topchunk合并，如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，则会调用malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中

#### 一些能触发的tricks

- scanf输入类似1*0x1000，导致scanf拓展缓冲区，调用malloc分配，触发consolidate
- 没有setbuf（stdin, 0）即没有关闭stdin的缓冲区，getchar()会开辟一个很大的堆块，触发consolidate

```shell
pwndbg> bt

#0  __GI___libc_malloc (bytes=1024) at malloc.c:2902
#1  0x00007ffff7a7a1d5 in __GI__IO_file_doallocate (fp=0x7ffff7dd18e0 <_IO_2_1_stdin_>) at filedoalloc.c:127
#2  0x00007ffff7a88594 in __GI__IO_doallocbuf (fp=fp@entry=0x7ffff7dd18e0 <_IO_2_1_stdin_>) at genops.c:398
#3  0x00007ffff7a8769c in _IO_new_file_underflow (fp=0x7ffff7dd18e0 <_IO_2_1_stdin_>) at fileops.c:556
#4  0x00007ffff7a8860e in __GI__IO_default_uflow (fp=0x7ffff7dd18e0 <_IO_2_1_stdin_>) at genops.c:413
#5  0x00007ffff7a83255 in getchar () at getchar.c:37
```

- top_chunk耗尽，会不断的把fastbin解链，放进unsortedbin。并合并

```python
pwndbg> x/100gx 0x5625e8d03af0
0x5625e8d03af0: 0x0000000000000000      0x0000000000000141
0x5625e8d03b00: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03b10: 0x0000000000000000      0x0000000000000121  #往下是几个不同的fastbin产生的合并
0x5625e8d03b20: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03b30: 0x0000000000000000      0x0000000000000000
0x5625e8d03b40: 0x0000000000000000      0x00000000000000f1
0x5625e8d03b50: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03b60: 0x0000000000000000      0x0000000000000000
0x5625e8d03b70: 0x0000000000000000      0x00000000000000c1
0x5625e8d03b80: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03b90: 0x0000000000000000      0x0000000000000000
0x5625e8d03ba0: 0x0000000000000000      0x0000000000000091
0x5625e8d03bb0: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03bc0: 0x0000000000000000      0x0000000000000000
0x5625e8d03bd0: 0x0000000000000000      0x0000000000000061
0x5625e8d03be0: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03bf0: 0x0000000000000000      0x0000000000000000
0x5625e8d03c00: 0x0000000000000000      0x0000000000000031
0x5625e8d03c10: 0x00007fcb29a82be0      0x00007fcb29a82be0
0x5625e8d03c20: 0x0000000000000000      0x0000000000000000
0x5625e8d03c30: 0x0000000000000140      0x0000000000000030
0x5625e8d03c40: 0x0000000000000000      0x0000000000000000
0x5625e8d03c50: 0x0000000000000000      0x0000000000000000
0x5625e8d03c60: 0x0000000000000000      0x0000000000000021
0x5625e8d03c70: 0x0000000000000000      0x0000000000000000
0x5625e8d03c80: 0x0000000000000000      0x0000000000000000
```



### Glibc_2.29_unsortedbin_attack_replace

#### smallbin_attack

#### largebin_attack

[两种方式利用 one punch man]: https://www.freebuf.com/column/237497.html





### Tcache_stashing_unlink_attack

### some-heap-tips

#### 如何产生0x60的smallbin

##### 利用切割

```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
	void *p = malloc(0x80);//创建一个大于0x80的chunk
	malloc(0x10);//防止后面free时归入top chunk
	free(p);//产生一个0x90的unsortedbin
	malloc(0x20);//从0x90的unsortedbin中割去0x30，还剩一个0x60的unsortedbin
	malloc(0x60);//malloc一个0x70的chunk，此时unsortedbin不够大，系统把此时的unsortedbin归类到smallbin下
	return 0;
}
```

##### 利用malloc-consolidate

- 具体过程是，fastbin先合并成unsortedbin，然后由于申请的size不够，就将其放至对应的smallbin

```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
	void *p = malloc(0x50);
	malloc(0x10);
	free(p);//此时p为fastbin
	malloc(0x3f0);//0x400 (large chunk)
	return 0;//此时p为smallbin
}
```

##### 有Tcache的情况

- 与上面的差别就是需要先填满Tcache即可

#### 几种restrict产生unsortedbin

##### 没有free

```python
目标：在没有free的情况下产生unsorted bin
条件：能够修改top chunk的size
做法：
1.覆盖top chunk的size，使&top+size为pagealigned，一般来说即size = size&0xfff;   #页对齐
2.申请一个大于size且小于0x20000的chunk，此时top_chunk会被free，进入unsorted bin
```

##### size limit限制申请大小

**Tag**：只能申请fastbin大小，又要产生unsortedbin，自然联想到malloc consolidate中的一些操作

​          常常和NUll off-by-one配合，但null-off-by-one需要大于0x100的chunk，才能shrink

- **有scanf**

```python
'''
1. 先释放几个fastbin
2. 利用scanf超长，产生malloc largin ————> malloc_consolidate ----> 合并fastbin放入unsortedbin ----> 得到size>0x100的chunk 
'''
```

- **耗尽Topchunk**

##### 2.28 - onegadget

http://matshao.com/2019/03/28/Babayheap-2019/

```python
'''
So next time when you meet the situation in libc-2.28, feel confident to set __malloc_hook to libc+0x105ae0 and __realloc_hook to second one gadget.
'''
```

##### calloc

- 不从tcache申请
- free进tcache
- ​                                   